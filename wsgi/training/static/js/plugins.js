// Generated by CoffeeScript 1.9.1
var bestSplitGeneric, bestSplitSpeed, changeSummary, convertTrack, createCadChart, createCadZones, createChart, createElevationChart, createElevationZones, createGradeChart, createGradeZones, createHrChart, createHrZones, createMap, createOchart, createSpeedChart, createSpeedZones, createTempChart, createTempZones, createWchart, createZones, findBestSplits, formatDistance, formatShortDistance, formatSpeed, formatTime, getActivityId, getBounds, groupData, initialSum, movePointerEvent, parseSplitArgs, pointer, points, round_, setMovePointerEvent, toSIBase, updateTooltip;

round_ = function(value, places) {
  var multi;
  if (places == null) {
    places = 2;
  }
  multi = Math.pow(10, places);
  return Math.round(value * multi) / multi;
};

updateTooltip = function(x) {
  var chart, k, len, ref, results;
  ref = Highcharts.charts;
  results = [];
  for (k = 0, len = ref.length; k < len; k++) {
    chart = ref[k];
    chart.tooltip.refresh([chart.series[0].points[x]]);
    results.push(chart.series[0].data[x].setState('hover'));
  }
  return results;
};

getActivityId = function() {
  var url;
  url = document.location.pathname.split('/');
  return url[url.length - 1];
};

groupData = function(data) {
  var count, i, increment, k, len, local_max, max, min, new_data, point;
  min = data[0][0];
  max = data[data.length - 1][0];
  increment = Math.ceil((max - min) / 25);
  local_max = min + increment;
  new_data = [];
  i = 0;
  count = 0;
  for (k = 0, len = data.length; k < len; k++) {
    point = data[k];
    if (local_max < point[0]) {
      i += 1;
      local_max += increment;
    }
    count += point[1];
    if (new_data[i] != null) {
      new_data[i][1] += point[1];
    } else {
      new_data[i] = [];
      new_data[i][0] = local_max - increment;
      new_data[i][1] = point[1];
    }
  }
  return [new_data, count];
};

toSIBase = function(value, units) {
  var multi;
  multi = 1;
  if (units.charAt(0) === 'k') {
    multi *= 1000;
  }
  if (units === 'mile') {
    multi *= 1609;
  }
  if (units === 'ft') {
    multi *= 0.3048;
  }
  if (units === 'min') {
    multi *= 60;
  }
  if (units === 'h') {
    multi *= 3600;
  }
  return value * multi;
};

formatTime = function(value, has_seconds) {
  var hours, minutes, seconds, str_min, str_sec;
  if (has_seconds == null) {
    has_seconds = false;
  }
  seconds = value % 60;
  minutes = Math.floor(value / 60) % 60;
  hours = Math.floor(value / 3600);
  str_min = minutes < 10 ? "0" + minutes : "" + minutes;
  if (!has_seconds) {
    return hours + ":" + str_min;
  } else {
    str_sec = seconds < 10 ? "0" + seconds : "" + seconds;
    return hours + ":" + str_min + ":" + str_sec;
  }
};

formatDistance = function(value) {
  var d_str, multi, round_precision, val;
  if (SI_UNITS) {
    multi = 1 / 1000;
  } else {
    multi = 1 / 1609;
  }
  val = value * multi;
  round_precision = val < 1 ? 2 : 1;
  d_str = round_(value * multi, round_precision);
  return d_str + " " + UNITS.distance;
};

formatShortDistance = function(value) {
  var d_str, multi;
  if (SI_UNITS) {
    multi = 1;
  } else {
    multi = 3.281;
  }
  d_str = round_(value * multi, 0);
  return d_str + " " + UNITS.height;
};

formatSpeed = function(value) {
  var multi, s_str;
  if (SI_UNITS) {
    multi = 3.6;
  } else {
    multi = 2.237;
  }
  s_str = round_(value * multi, 1);
  return s_str + " " + UNITS.speed;
};

createOchart = function(data, height) {
  var e, multi_speed;
  if (height == null) {
    height = 200;
  }
  multi_speed = SI_UNITS ? 3.6 : 2.237;
  data[1] = (function() {
    var k, len, ref, results;
    ref = data[1];
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      e = ref[k];
      results.push([e[0], round_(e[1] * multi_speed, 2)]);
    }
    return results;
  })();
  if (!SI_UNITS) {
    data[0] = (function() {
      var k, len, ref, results;
      ref = data[0];
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        e = ref[k];
        results.push([e[0], round_(e[1] * 3.281, 0)]);
      }
      return results;
    })();
  }
  return $('#ochart').highcharts({
    chart: {
      height: height
    },
    credits: {
      enabled: false
    },
    legend: {
      enabled: false
    },
    title: {
      text: null
    },
    plotOptions: {
      series: {
        point: {
          events: {
            mouseOver: function(event) {
              return movePointerEvent(this.index);
            }
          }
        }
      }
    },
    tooltip: {
      shared: true,
      crosshairs: true,
      formatter: function() {
        var distance, elevation, speed;
        distance = this.x / 1000 + (" " + UNITS.distance);
        elevation = this.points[0].y + (" " + UNITS.height);
        speed = this.points[1].y + (" " + UNITS.speed);
        return "<b>" + distance + "</b><br>Elevation: " + elevation + "<br>Speed: " + speed;
      }
    },
    series: [
      {
        name: 'Elevation',
        data: data[0],
        yAxis: 0
      }, {
        name: 'Speed',
        data: data[1],
        yAxis: 1
      }
    ],
    xAxis: {
      labels: {
        formatter: function() {
          return this.value / 1000 + (" " + UNITS.distance);
        }
      }
    },
    yAxis: [
      {
        id: 0,
        title: {
          enabled: false
        },
        labels: {
          formatter: function() {
            return this.value + (" " + UNITS.height);
          }
        }
      }, {
        id: 1,
        min: 0,
        labels: {
          align: 'left',
          formatter: function() {
            return this.value + (" " + UNITS.speed);
          }
        },
        opposite: true,
        title: {
          enabled: false
        }
      }
    ]
  });
};

createChart = function(target, name, color, data, units) {
  var v;
  return $(target).highcharts({
    chart: {
      height: 150
    },
    colors: [color],
    credits: {
      enabled: false
    },
    legend: {
      enabled: false
    },
    plotOptions: {
      series: {
        point: {
          events: {
            mouseOver: function(event) {
              return updateTooltip(this.index);
            }
          }
        }
      }
    },
    title: {
      text: name,
      floating: true
    },
    tooltip: {
      shared: true,
      crosshairs: true,
      formatter: function() {
        var distance, val;
        distance = round_(this.x / 1000, 2) + (" " + UNITS.distance);
        val = this.points[0].y + (" " + units);
        return "<b>" + distance + "</b><br>" + name + ": " + val;
      }
    },
    series: [
      {
        name: name,
        data: data
      }
    ],
    xAxis: {
      labels: {
        formatter: function() {
          return this.value / 1000 + (" " + UNITS.distance);
        }
      }
    },
    yAxis: [
      {
        id: 0,
        min: Math.min.apply(null, (function() {
          var k, len, results;
          results = [];
          for (k = 0, len = data.length; k < len; k++) {
            v = data[k];
            results.push(v[1]);
          }
          return results;
        })()),
        title: {
          enabled: false
        },
        labels: {
          formatter: function() {
            return this.value + (" " + units);
          }
        }
      }
    ]
  });
};

createElevationChart = function(data) {
  var e;
  if (!SI_UNITS) {
    data = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = data.length; k < len; k++) {
        e = data[k];
        results.push([e[0], round_(e[1] * 3.281, 0)]);
      }
      return results;
    })();
  }
  return createChart('#elevation_chart', 'Elevation', 'red', data, UNITS.height);
};

createSpeedChart = function(data) {
  var e, multi_speed;
  multi_speed = SI_UNITS ? 3.6 : 2.237;
  data = (function() {
    var k, len, results;
    results = [];
    for (k = 0, len = data.length; k < len; k++) {
      e = data[k];
      results.push([e[0], round_(e[1] * multi_speed, 2)]);
    }
    return results;
  })();
  return createChart('#speed_chart', 'Speed', 'green', data, UNITS.speed);
};

createGradeChart = function(data) {
  return createChart('#grade_chart', 'Grade', 'blue', data, UNITS.percent);
};

createHrChart = function(data) {
  return createChart('#hr_chart', 'Heart rate', 'orange', data, UNITS.per_min);
};

createCadChart = function(data) {
  return createChart('#cad_chart', 'Cadence', 'pink', data, UNITS.per_min);
};

createTempChart = function(data) {
  var e;
  if (!SI_UNITS) {
    data = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = data.length; k < len; k++) {
        e = data[k];
        results.push([e[0], round_(e[1] * 1.8 + 32, 0)]);
      }
      return results;
    })();
  }
  return createChart('#temp_chart', 'Temperature', 'purple', data, UNITS.temperature);
};

createZones = function(target, name, color, data, units) {
  var count, i, k, len, ref, val;
  ref = groupData(data), data = ref[0], count = ref[1];
  for (i = k = 0, len = data.length; k < len; i = ++k) {
    val = data[i];
    data[i][1] = val[1] / count * 100;
  }
  return $(target).highcharts({
    chart: {
      type: 'column',
      height: 200
    },
    colors: [color],
    credits: {
      enabled: false
    },
    legend: {
      enabled: false
    },
    title: {
      text: name,
      floating: true
    },
    tooltip: {
      shared: true,
      crosshairs: true,
      formatter: function() {
        var percent;
        val = this.x + (" " + units);
        percent = round_(this.points[0].y, 2) + " %";
        return "<b>" + val + "</b><br>" + percent;
      }
    },
    series: [
      {
        name: name,
        data: data
      }
    ],
    xAxis: {
      labels: {
        formatter: function() {
          return this.value + (" " + units);
        }
      }
    },
    yAxis: [
      {
        id: 0,
        title: {
          enabled: false
        },
        labels: {
          formatter: function() {
            return this.value + " %";
          }
        }
      }
    ]
  });
};

createElevationZones = function(data) {
  var e;
  if (!SI_UNITS) {
    data = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = data.length; k < len; k++) {
        e = data[k];
        results.push([e[0], round_(e[1] * 3.281, 0)]);
      }
      return results;
    })();
  }
  return createZones('#elevation_zones', 'Elevation', 'red', data, UNITS.height);
};

createSpeedZones = function(data) {
  var e, multi_speed;
  multi_speed = SI_UNITS ? 3.6 : 2.237;
  data = (function() {
    var k, len, results;
    results = [];
    for (k = 0, len = data.length; k < len; k++) {
      e = data[k];
      results.push([e[0], round_(e[1] * multi_speed, 2)]);
    }
    return results;
  })();
  return createZones('#speed_zones', 'Speed', 'green', data, UNITS.speed);
};

createGradeZones = function(data) {
  return createZones('#grade_zones', 'Grade', 'blue', data, UNITS.percent);
};

createHrZones = function(data) {
  return createZones('#hr_zones', 'Heart rate', 'orange', data, UNITS.per_min);
};

createCadZones = function(data) {
  return createZones('#cad_zones', 'Cadence', 'pink', data, UNITS.per_min);
};

createTempZones = function(data) {
  var e;
  if (!SI_UNITS) {
    data = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = data.length; k < len; k++) {
        e = data[k];
        results.push([e[0], round_(e[1] * 1.8 + 32, 0)]);
      }
      return results;
    })();
  }
  return createZones('#temp_zones', 'Temperature', 'purple', data, UNITS.temperature);
};

convertTrack = function(points) {
  var extremes, k, latLng, len, point, x, y;
  latLng = [];
  extremes = {
    x: {
      min: 180,
      max: -180
    },
    y: {
      min: 90,
      max: -90
    }
  };
  for (k = 0, len = points.length; k < len; k++) {
    point = points[k];
    x = point[0];
    y = point[1];
    latLng.push(new google.maps.LatLng(x, y));
    if (x < extremes.x.min) {
      extremes.x.min = x;
    } else if (x > extremes.x.max) {
      extremes.x.max = x;
    }
    if (y < extremes.y.min) {
      extremes.y.min = y;
    } else if (y > extremes.y.max) {
      extremes.y.max = y;
    }
  }
  return {
    extremes: extremes,
    points: latLng
  };
};

getBounds = function(extremes) {
  var bounds, max, min;
  bounds = new google.maps.LatLngBounds;
  min = new google.maps.LatLng(extremes.x.min, extremes.y.min);
  max = new google.maps.LatLng(extremes.x.max, extremes.y.max);
  bounds.extend(min);
  bounds.extend(max);
  return bounds;
};

points = null;

pointer = null;

setMovePointerEvent = function(ptr, pts) {
  pointer = ptr;
  return points = pts;
};

movePointerEvent = function(index) {
  if (!pointer || !points) {
    return;
  }
  return pointer.setPosition(points[index]);
};

createMap = function(data) {
  var bounds, center, map, marker, polyline, track;
  track = convertTrack(data);
  center = new google.maps.LatLng((track.extremes.x.max + track.extremes.x.min) / 2, (track.extremes.y.max + track.extremes.y.min) / 2);
  bounds = getBounds(track.extremes);
  map = new google.maps.Map(document.getElementById('map'), {
    zoom: 10,
    center: center,
    mapTypeId: google.maps.MapTypeId.TERRAIN
  });
  map.fitBounds(bounds);
  polyline = new google.maps.Polyline({
    path: track.points,
    strokeColor: '#FF0000',
    strokeOpacity: 1.0,
    strokeWeight: 4,
    editable: false
  });
  polyline.setMap(map);
  marker = new google.maps.Marker({
    icon: {
      path: google.maps.SymbolPath.CIRCLE,
      scale: 7,
      fillColor: '#6CC9EB',
      fillOpacity: 1.0,
      strokeColor: '#FFFFFF',
      strokeOpacity: 1.0,
      strokeWeight: 2
    }
  });
  setMovePointerEvent(marker, track.points);
  return marker.setMap(map);
};

findBestSplits = function(data) {
  return $('td[data-best-split]').each(function() {
    var args, interval, ref, si_val;
    args = parseSplitArgs($(this).attr('data-best-split'));
    if ((ref = args.what) === 'cad' || ref === 'hr' || ref === 'elevation') {
      interval = args.type === 'distance' ? args.interval * 100 : args.interval;
      si_val = bestSplitGeneric(data[args.type], data[args.what], interval, false);
      return $(this).text(args.what === 'elevation' ? formatShortDistance(si_val) : si_val);
    } else if (args.what === 'speed') {
      interval = args.type === 'distance' ? args.interval * 100 : args.interval;
      si_val = bestSplitSpeed(data.time, data.distance, interval, args.type === 'time');
      return $(this).text(formatSpeed(si_val));
    } else {
      interval = args.type === 'distance' ? args.interval * 100 : args.interval;
      si_val = bestSplitGeneric(data[args.type], data[args.what], interval, true, args.type === 'distance');
      return $(this).text(args.type === 'time' ? formatDistance(si_val / 100) : formatTime(si_val, true));
    }
  });
};

parseSplitArgs = function(str) {
  var attrs, interval, ref;
  attrs = str.split('-');
  interval = toSIBase(parseFloat(attrs[1]), attrs[2]);
  return {
    what: attrs[0],
    type: (ref = attrs[2]) === 's' || ref === 'min' || ref === 'h' ? 'time' : 'distance',
    interval: interval
  };
};

bestSplitGeneric = function(control, data, interval, as_delta, prefer_min) {
  var best, choose_best, current, d, delta, i, j, k, len, prev, ref, ref1, start;
  if (as_delta == null) {
    as_delta = true;
  }
  if (prefer_min == null) {
    prefer_min = false;
  }
  choose_best = prefer_min ? Math.min : Math.max;
  best = prefer_min ? Number.MAX_VALUE : 0;
  ref = initialSum(control, data, interval, as_delta), start = ref[0], delta = ref[1], current = ref[2];
  prev = data[start - 1];
  j = 0;
  ref1 = data.slice(start);
  for (i = k = 0, len = ref1.length; k < len; i = ++k) {
    d = ref1[i];
    if (as_delta) {
      current += d;
    } else {
      current += d - prev;
      prev = d;
    }
    delta += control[i + start];
    if (delta > interval) {
      best = choose_best(current, best);
      while (delta > interval) {
        if (as_delta) {
          current -= data[j];
        } else {
          current -= data[j - 1] ? data[j] - data[j - 1] : 0;
        }
        delta -= control[j];
        j += 1;
      }
    }
  }
  return best;
};

bestSplitSpeed = function(time, distance, interval, interval_time) {
  var best, c, c_dist, c_time, control, delta, i, j, k, len, ref, ref1, start;
  if (interval_time == null) {
    interval_time = true;
  }
  best = 0;
  control = interval_time ? time : distance;
  ref = initialSum(control, distance, interval, true), start = ref[0], delta = ref[1], c_dist = ref[2];
  c_time = (initialSum(control, time, interval, true))[2];
  j = 0;
  ref1 = control.slice(start);
  for (i = k = 0, len = ref1.length; k < len; i = ++k) {
    c = ref1[i];
    c_time += time[i + start];
    c_dist += distance[i + start];
    delta += c;
    if (delta > interval) {
      best = Math.max(round_(c_dist / c_time / 100, 1), best);
      while (delta > interval) {
        c_time -= time[j];
        c_dist -= distance[j];
        delta -= control[j];
        j += 1;
      }
    }
  }
  return best;
};

initialSum = function(control, data, interval, as_delta) {
  var delta, i, prev, sum;
  if (as_delta == null) {
    as_delta = true;
  }
  sum = 0;
  delta = 0;
  i = 0;
  prev = data[0];
  while (delta < interval && i < data.length) {
    i += 1;
    if (as_delta) {
      sum += data[i];
    } else {
      sum += data[i] - prev;
      prev = data[i];
    }
    delta += control[i];
  }
  return [i, delta, sum];
};

changeSummary = function() {
  var period;
  period = $('#summary_for').val();
  return $.getJSON("/activities/api/summary/" + period, function(json) {
    var results, target, value;
    results = [];
    for (target in json) {
      value = json[target];
      switch (target) {
        case 'total_time':
          results.push($("#" + target).text(formatTime(value)));
          break;
        case 'longest':
          results.push($("#" + target).text(formatTime(value)));
          break;
        case 'avg_duration':
          results.push($("#" + target).text(formatTime(value)));
          break;
        case 'farthest':
          results.push($("#" + target).text(formatDistance(value)));
          break;
        case 'total_distance':
          results.push($("#" + target).text(formatDistance(value)));
          break;
        case 'avg_distance':
          results.push($("#" + target).text(formatDistance(value)));
          break;
        case 'max_speed':
          results.push($("#" + target).text(formatSpeed(value / 360)));
          break;
        case 'avg_speed':
          results.push($("#" + target).text(formatSpeed(value)));
          break;
        case 'elev_gain':
          results.push($("#" + target).text(formatShortDistance(value)));
          break;
        default:
          results.push($("#" + target).text(value !== null ? value : 0));
      }
    }
    return results;
  });
};

createWchart = function(data) {
  return $('#wchart').highcharts({
    chart: {
      type: 'column',
      height: 300
    },
    credits: {
      enabled: false
    },
    legend: {
      enabled: false
    },
    title: {
      text: name,
      floating: true
    },
    tooltip: {
      shared: true,
      crosshairs: true,
      formatter: function() {
        return "<b>Dist</b>: " + (this.points[0].y / 1000) + " " + UNITS.distance + "<br><b>Time</b>: " + (formatTime(this.points[1].y)) + "<br><b>Rating</b>: " + this.points[2].y + "<br><b>#</b>: " + this.points[3].y;
      }
    },
    series: [
      {
        name: 'Distance',
        data: data.distance,
        yAxis: 0
      }, {
        name: 'Time',
        data: data.time,
        yAxis: 1
      }, {
        name: 'Rating',
        data: data.rating,
        yAxis: 2
      }, {
        name: 'N',
        data: data.n,
        yAxis: 3
      }
    ],
    xAxis: {
      labels: {
        formatter: function() {
          return this.value;
        }
      }
    },
    yAxis: [
      {
        id: 0,
        title: {
          text: 'Distance',
          enabled: false
        },
        labels: {
          enabled: false,
          formatter: function() {
            return this.value / 1000 + (" " + UNITS.distance);
          }
        }
      }, {
        id: 1,
        title: {
          text: 'Time',
          enabled: false
        },
        labels: {
          enabled: false,
          formatter: function() {
            return formatTime(this.value);
          }
        }
      }, {
        id: 2,
        opposite: true,
        title: {
          text: 'Rating',
          enabled: false
        },
        labels: {
          enabled: false,
          formatter: function() {
            return this.value;
          }
        }
      }, {
        id: 3,
        opposite: true,
        title: {
          text: '#',
          enabled: false
        },
        labels: {
          enabled: false,
          forrmatter: function() {
            return this.value;
          }
        }
      }
    ]
  });
};

$(function() {
  var id;
  $('select').selecter();
  $('[data-toggle="tooltip"]').tooltip();
  id = getActivityId();
  $('[data-action="delete-activity"]').click(function(e) {
    if (!confirm('Are you sure you want to delete this activity?')) {
      return e.preventDefault();
    }
  });
  if ($('#id_date').length) {
    new Pikaday({
      field: $('#id_date')[0],
      format: 'YYYY-MM-DD'
    });
  }
  if ($('#map').length) {
    $.getJSON("/activities/api/map/" + id, function(json) {
      return createMap(json);
    });
  }
  if ($('.bm-nav').length) {
    $.getJSON("/activities/api/ochart/" + id, function(json) {
      return createOchart(json, 150);
    });
  } else if ($('#ochart').length) {
    $.getJSON("/activities/api/ochart/" + id, function(json) {
      return createOchart(json);
    });
  }
  if ($('#elevation_chart').length) {
    $.getJSON("/activities/api/chart/" + id + "/elevation", function(json) {
      return createElevationChart(json);
    });
  }
  if ($('#speed_chart').length) {
    $.getJSON("/activities/api/chart/" + id + "/speed", function(json) {
      return createSpeedChart(json);
    });
  }
  if ($('#grade_chart').length) {
    $.getJSON("/activities/api/chart/" + id + "/grade", function(json) {
      return createGradeChart(json);
    });
  }
  if ($('#hr_chart').length) {
    $.getJSON("/activities/api/chart/" + id + "/hr", function(json) {
      return createHrChart(json);
    });
  }
  if ($('#cad_chart').length) {
    $.getJSON("/activities/api/chart/" + id + "/cadence", function(json) {
      return createCadChart(json);
    });
  }
  if ($('#temp_chart').length) {
    $.getJSON("/activities/api/chart/" + id + "/temperature", function(json) {
      return createTempChart(json);
    });
  }
  if ($('#elevation_zones').length) {
    $.getJSON("/activities/api/zones/" + id + "/elevation", function(json) {
      return createElevationZones(json);
    });
  }
  if ($('#speed_zones').length) {
    $.getJSON("/activities/api/zones/" + id + "/speed", function(json) {
      return createSpeedZones(json);
    });
  }
  if ($('#grade_zones').length) {
    $.getJSON("/activities/api/zones/" + id + "/grade", function(json) {
      return createGradeZones(json);
    });
  }
  if ($('#hr_zones').length) {
    $.getJSON("/activities/api/zones/" + id + "/hr", function(json) {
      return createHrZones(json);
    });
  }
  if ($('#cad_zones').length) {
    $.getJSON("/activities/api/zones/" + id + "/cadence", function(json) {
      return createCadZones(json);
    });
  }
  if ($('#temp_zones').length) {
    $.getJSON("/activities/api/zones/" + id + "/temperature", function(json) {
      return createTempZones(json);
    });
  }
  if ($('td[data-best-split]').length) {
    $.getJSON("/activities/api/track/" + id, function(json) {
      return findBestSplits(json);
    });
  }
  if ($('#summary_for').length) {
    changeSummary();
    $('#summary_for').change(changeSummary);
  }
  if ($('#wchart').length) {
    return $.getJSON("/activities/api/wchart", function(json) {
      return createWchart(json);
    });
  }
});
